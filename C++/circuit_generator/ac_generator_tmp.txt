// Generate AC Steady State Circuit
Circuit generateACCircuit() {
    int w = 3;
    int h = 3;
    Circuit circuit(w, h);
    circuit.exerciseType = AC_STEADY_STATE;
    
    // Track edges
    std::vector<std::pair<int, int>> edges;
    std::set<std::pair<int, int>> existingEdges;
    
    int numNodes = w * h;
    std::vector<int> visited = {0};
    std::vector<int> unvisited;
    for(int i=1; i<numNodes; ++i) unvisited.push_back(i);
    
    auto addEdge = [&](int u, int v) {
        if (u > v) std::swap(u, v);
        if (existingEdges.find({u, v}) == existingEdges.end()) {
            existingEdges.insert({u, v});
            edges.push_back({u, v});
        }
    };
    
    auto getNeighbors = [&](int u) {
        std::vector<int> n;
        int x = u % w;
        int y = u / w;
        if (x > 0) n.push_back(u - 1);
        if (x < w - 1) n.push_back(u + 1);
        if (y > 0) n.push_back(u - w);
        if (y < h - 1) n.push_back(u + w);
        return n;
    };
   
    // Spanning tree
    while (!unvisited.empty()) {
        std::vector<std::pair<int, int>> candidates;
        for (int u : visited) {
            for (int v : getNeighbors(u)) {
                bool isUnvisited = false;
                for(int uv : unvisited) if(uv == v) isUnvisited = true;
                if (isUnvisited) {
                    candidates.push_back({u, v});
                }
            }
        }
        if (candidates.empty()) break;
        int idx = rand() % candidates.size();
        std::pair<int, int> edge = candidates[idx];
        addEdge(edge.first, edge.second);
        visited.push_back(edge.second);
        for(size_t i=0; i<unvisited.size(); ++i) {
            if (unvisited[i] == edge.second) {
                unvisited.erase(unvisited.begin() + i);
                break;
            }
        }
    }
    
    // Add extra edges
    int cyclesToAdd = 4;
    for (int i=0; i<cyclesToAdd * 10; ++i) {
        if (cyclesToAdd <= 0) break;
        int u = rand() % numNodes;
        auto neighbors = getNeighbors(u);
        int v = neighbors[rand() % neighbors.size()];
        int u_s = std::min(u, v);
        int v_s = std::max(u, v);
        if (existingEdges.find({u_s, v_s}) == existingEdges.end()) {
            addEdge(u_s, v_s);
            cyclesToAdd--;
        }
    }
    
    // Assign components
    int rCount = 0, vCount = 0, iCount = 0, cCount = 0, lCount = 0;
    
    // Decide number of sources (1 or 2)
    int numSources = (rand() % 2 == 0) ? 1 : 2;
    int sourcesPlaced = 0;
    
    auto isPerimeter = [&](int n) {
        int x = n % w;
        int y = n / w;
        return x==0 || x==w-1 || y==0 || y==h-1;
    };
    
    std::random_shuffle(edges.begin(), edges.end());
    
    // Place at least 2 reactive components (L/C)
    int reactiveCount = 0;
    int reactiveTarget = 2 + rand() % 2; // 2-3 reactive components
    
    for (const auto& edge : edges) {
        Component c;
        c.nodeA_idx = edge.first;
        c.nodeB_idx = edge.second;
        c.pA = circuit.nodes[edge.first];
        c.pB = circuit.nodes[edge.second];
        
        bool perimeterEdge = isPerimeter(edge.first) && isPerimeter(edge.second);
        
        // Priority 1: Place reactive components
        if (reactiveCount < reactiveTarget && (rand() % 10 < 4)) {
            if (rand() % 2 == 0) {
                c.type = CAPACITOR;
                c.name = "C" + std::to_string(++cCount);
                c.value = 1.0 * (rand()%10 + 1); // µF
            } else {
                c.type = INDUCTOR;
                c.name = "L" + std::to_string(++lCount);
                c.value = 1.0 * (rand()%10 + 1); // mH
            }
            reactiveCount++;
            circuit.addComponent(c);
            continue;
        }
        
        // Priority 2: Sources
        if (sourcesPlaced < numSources && perimeterEdge) {
            if (rand() % 2 == 0) {
                c.type = VOLTAGE_SOURCE;
                c.name = "V" + std::to_string(++vCount);
                c.value = 5.0 * (rand()%4 + 1);
            } else {
                c.type = CURRENT_SOURCE;
                c.name = "I" + std::to_string(++iCount);
                c.value = 1.0 * (rand()%3 + 1);
            }
            sourcesPlaced++;
            circuit.addComponent(c);
            continue;
        }
        
        // Default: Resistors
        c.type = RESISTOR;
        c.name = "R" + std::to_string(++rCount);
        c.value = 10.0 * (rand()%10 + 1);
        circuit.addComponent(c);
    }
    
    // Ensure we have at least one source
    if (sourcesPlaced == 0) {
        Component& c = circuit.components[0];
        c.type = VOLTAGE_SOURCE;
        c.name = "V1";
        c.value = 10.0;
        sourcesPlaced = 1;
    }
    
    // Ensure we have at least 2 reactive components
    if (reactiveCount < 2) {
        for (size_t i = 0; i < circuit.components.size() && reactiveCount < 2; ++i) {
            if (circuit.components[i].type == RESISTOR) {
                if (rand() % 2 == 0) {
                    circuit.components[i].type = CAPACITOR;
                    circuit.components[i].name = "C" + std::to_string(++cCount);
                    circuit.components[i].value = 1.0 * (rand()%10 + 1);
                } else {
                    circuit.components[i].type = INDUCTOR;
                    circuit.components[i].name = "L" + std::to_string(++lCount);
                    circuit.components[i].value = 1.0 * (rand()%10 + 1);
                }
                reactiveCount++;
            }
        }
    }
    
    // Pick 1-3 resistors for power calculation
    std::vector<Component*> resistors;
    for (auto& c : circuit.components) {
        if (c.type == RESISTOR) resistors.push_back(&c);
    }
    
    int numPowerQuestions = std::min((int)resistors.size(), 1 + rand() % 3);
    std::random_shuffle(resistors.begin(), resistors.end());
    for (int i = 0; i < numPowerQuestions && i < (int)resistors.size(); ++i) {
        resistors[i]->highlightRed = true;
        circuit.targetResistors.push_back(resistors[i]);
    }
    
    // ===== INTELLIGENT FREQUENCY SELECTION =====
    int strategy = rand() % 10;
    
    if (strategy < 4 && cCount > 0 && lCount > 0) {
        // Strategy 1 (40%): Resonance - ω = 1/√(LC)
        Component* selectedL = nullptr;
        Component* selectedC = nullptr;
        for (auto& c : circuit.components) {
            if (!selectedL && c.type == INDUCTOR) selectedL = &c;
            if (!selectedC && c.type == CAPACITOR) selectedC = &c;
            if (selectedL && selectedC) break;
        }
        
        if (selectedL && selectedC) {
            double L_h = selectedL->value * 1e-3;
            double C_f = selectedC->value * 1e-6;
            circuit.omega = 1.0 / std::sqrt(L_h * C_f);
            circuit.frequency = circuit.omega / (2.0 * 3.14159265359);
        } else {
            circuit.omega = 1000.0;
            circuit.frequency = circuit.omega / (2.0 * 3.14159265359);
        }
    } else if (strategy < 8) {
        // Strategy 2 (40%): Unit simplification - ω = 1000 rad/s
        circuit.omega = 1000.0;
        circuit.frequency = circuit.omega / (2.0 * 3.14159265359);
    } else {
        // Strategy 3 (20%): Random
        circuit.omega = 100.0 + rand() % 4900; // 100-5000 rad/s
        circuit.frequency = circuit.omega / (2.0 * 3.14159265359);
    }
    
    // Generate question text
    std::stringstream ss;
    ss << "AC Circuit with i_s(t) = I_peak*sin(" << (int)circuit.omega << "t) A. ";
    
    if (!circuit.targetResistors.empty()) {
        ss << "Calculate average power absorbed by ";
        for (size_t i = 0; i < circuit.targetResistors.size(); ++i) {
            ss << circuit.targetResistors[i]->name;
            if (i < circuit.targetResistors.size() - 1) ss << ", ";
        }
        ss << ". ";
    }
    
    if (sourcesPlaced == 1) {
        ss << "Calculate power factor of the generator.";
    }
    
    circuit.questionText = ss.str();
    
    return circuit;
}
